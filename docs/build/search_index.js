var documenterSearchIndex = {"docs":
[{"location":"","page":"-","title":"-","text":"CurrentModule = MinimaxAdaptiveControl","category":"page"},{"location":"","page":"-","title":"-","text":"Modules = [MinimaxAdaptiveControl]\nOrder   = [:function, :type]","category":"page"},{"location":"#Main.MinimaxAdaptiveControl.K-Tuple{MAController}","page":"-","title":"Main.MinimaxAdaptiveControl.K","text":"K(mac::MAController)\n\nReturns the feedback gain such that u = -Kx\n\n\n\n\n\n","category":"method"},{"location":"#Main.MinimaxAdaptiveControl.Pcommon-Union{Tuple{MAController{T}}, Tuple{T}} where T<:Number","page":"-","title":"Main.MinimaxAdaptiveControl.Pcommon","text":"Pcommon(mac::MAController) synthesizes a common P such that\n\nTO IMPLEMENT\n\nP >= Q + K'RK + (A-BK)(P^(-1) - 1/gamma^2I)^(-1)(A-BK) for all candidates (A,B,K).\n\n\n\n\n\n","category":"method"},{"location":"#Main.MinimaxAdaptiveControl.T-Union{Tuple{MAController{T}}, Tuple{T}} where T<:Number","page":"-","title":"Main.MinimaxAdaptiveControl.T","text":"T(mac::MAController) synthesizes a common T using convex\nprogramming such that\n\nTO IMPLEMENT!\n\nT >= Q + Kj'RKj + (Ai-BiKj)(P^(-1) - 1/gamma^2I)^(-1)(Ai-BiKj) and T >= Q + Kk'RKk ...\n\n\n\n\n\n","category":"method"},{"location":"#Main.MinimaxAdaptiveControl.dare-NTuple{4,Any}","page":"-","title":"Main.MinimaxAdaptiveControl.dare","text":"dare(A, B, Q, R)\n\nCompute X, the solution to the discrete-time algebraic Riccati equation, defined as A'XA - X - (A'XB)(B'XB + R)^-1(B'XA) + Q = 0, where Q>=0.\n\nThis version relaxes the requirement that R>0, rather R = [R1 0;0 R2] where R1 >0, R2 < 0. This is a usuful formulation for H_âˆž synthesis.\n\nAlgorithm taken from: Laub, \"A Schur Method for Solving Algebraic Riccati Equations.\" Relaxes the positive definiteness of R, useful for robust control.\n\nhttp://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf\n\nImplementation stolen from: ControlSystems.jl\n\n\n\n\n\n","category":"method"},{"location":"#Main.MinimaxAdaptiveControl.update!-Union{Tuple{T}, Tuple{MAController,AbstractArray{T,1},AbstractArray{T,1}}} where T<:Number","page":"-","title":"Main.MinimaxAdaptiveControl.update!","text":"update!(mac::MAController, \n    x::AbstractArray{T,1}, u::AbstractArray{T,1}) where T<:Number\n\nUpdate the internal states of the controller based  on current state x and control signal u.\n\n\n\n\n\n","category":"method"},{"location":"#Main.MinimaxAdaptiveControl.Candidate","page":"-","title":"Main.MinimaxAdaptiveControl.Candidate","text":"Candidate{T<:Number}\n\nFields:\n\nA::AbstractMatrix{T} System matrix\n\nB::AbstractMatrix{T} Input Gain matrix\n\nK::AbstractMatrix{T} H_infty` feedback gain\n\nP::AbstractMatrix{T} Stationary solution to the Riccati equation\n\nhist::Base.RefValue{<:Real} History, sum _k=0^N lambda^N-kx_k+1 - Ax_k -Bu_k^2\n\nlam::T Forgetting factor lambda\n\n\n\n\n\n","category":"type"}]
}
