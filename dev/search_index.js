var documenterSearchIndex = {"docs":
[{"location":"","page":"-","title":"-","text":"","category":"page"},{"location":"","page":"-","title":"-","text":"noteId: \"2828347064af11eb8191153eb319e31b\" tags: []","category":"page"},{"location":"","page":"-","title":"-","text":"","category":"page"},{"location":"","page":"-","title":"-","text":"CurrentModule = MinimaxAdaptiveControl","category":"page"},{"location":"","page":"-","title":"-","text":"Modules = [MinimaxAdaptiveControl]\nOrder   = [:function, :type]","category":"page"},{"location":"#MinimaxAdaptiveControl.K-Tuple{MAController}","page":"-","title":"MinimaxAdaptiveControl.K","text":"K(mac::MAController)\n\nReturns the feedback gain such that u = -Kx\n\n\n\n\n\n","category":"method"},{"location":"#MinimaxAdaptiveControl.Tsyn-Union{Tuple{M}, Tuple{MAController{M},JuMP.Model}, Tuple{MAController{M},JuMP.Model,Real}} where M<:Number","page":"-","title":"MinimaxAdaptiveControl.Tsyn","text":"T(mac::MAController) synthesizes a common T using convex\nprogramming such that\n\nTO IMPLEMENT!\n\nT >= Q + Kj'RKj + (Ai-BiKj)(P^(-1) - 1/gamma^2I)^(-1)(Ai-BiKj) and T >= Q + Kk'RKk ...\n\n\n\n\n\n","category":"method"},{"location":"#MinimaxAdaptiveControl.X-Union{Tuple{P}, Tuple{MAController{P},AbstractArray{T,2} where T,Integer,Integer}, Tuple{MAController{P},AbstractArray{T,2} where T,Integer,Integer,Real}} where P<:Number","page":"-","title":"MinimaxAdaptiveControl.X","text":"X(mac::MAController{P},\nT::Symmetric{VariableRef,Array{VariableRef,2}}, \ni::Integer, k::Integer) where P<:Number\n\nSynthesize a symmetric matrix X such that inequality (19) is satisfied iff X is positive semidefinite.\n\n\n\n\n\n","category":"method"},{"location":"#MinimaxAdaptiveControl.Z-Union{Tuple{P}, Tuple{MAController{P},AbstractArray{T,2} where T,Integer,Integer,Integer}, Tuple{MAController{P},AbstractArray{T,2} where T,Integer,Integer,Integer,Real}} where P<:Number","page":"-","title":"MinimaxAdaptiveControl.Z","text":"Z(mac::MAController{P},\nT::Symmetric{VariableRef,Array{VariableRef,2}}, \ni::Integer, j::Integer, k::Integer) where P<:Number\n\nSynthesize a symmetric matrix Z such that inequality (20) is satisfied iff Z is positive semidefinite.\n\n\n\n\n\n","category":"method"},{"location":"#MinimaxAdaptiveControl.dare-NTuple{4,Any}","page":"-","title":"MinimaxAdaptiveControl.dare","text":"dare(A, B, Q, R)\n\nCompute X, the solution to the discrete-time algebraic Riccati equation, defined as A'XA - X - (A'XB)(B'XB + R)^-1(B'XA) + Q = 0, where Q>=0.\n\nThis version relaxes the requirement that R>0, rather R = [R1 0;0 R2] where R1 >0, R2 < 0. This is a usuful formulation for H_âˆž synthesis.\n\nAlgorithm taken from: Laub, \"A Schur Method for Solving Algebraic Riccati Equations.\" Relaxes the positive definiteness of R, useful for robust control.\n\nhttp://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf\n\nImplementation stolen from: ControlSystems.jl\n\n\n\n\n\n","category":"method"},{"location":"#MinimaxAdaptiveControl.update!-Union{Tuple{T}, Tuple{MAController,AbstractArray{T,1},AbstractArray{T,1}}} where T<:Number","page":"-","title":"MinimaxAdaptiveControl.update!","text":"update!(mac::MAController, \n    x::AbstractArray{T,1}, u::AbstractArray{T,1}) where T<:Number\n\nUpdate the internal states of the controller based  on current state x and control signal u.\n\n\n\n\n\n","category":"method"},{"location":"#MinimaxAdaptiveControl.Candidate","page":"-","title":"MinimaxAdaptiveControl.Candidate","text":"Candidate{T<:Number}\n\nFields:\n\nA::AbstractMatrix{T} System matrix\n\nB::AbstractMatrix{T} Input Gain matrix\n\nK::AbstractMatrix{T} H_infty` feedback gain\n\nP::AbstractMatrix{T} Stationary solution to the Riccati equation\n\nhist::Base.RefValue{<:Real} History, sum _k=0^N lambda^N-kx_k+1 - Ax_k -Bu_k^2\n\nlam::T Forgetting factor lambda\n\n\n\n\n\n","category":"type"}]
}
